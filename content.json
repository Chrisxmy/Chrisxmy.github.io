{"meta":{"title":"Blog","subtitle":null,"description":null,"author":"shel","url":"http://yoursite.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-01-25T12:19:31.000Z","updated":"2018-01-09T07:38:06.000Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-01-25T12:19:31.000Z","updated":"2018-01-09T07:38:46.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2018-01-25T12:19:31.000Z","updated":"2018-01-09T07:38:54.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-01-25T12:19:31.000Z","updated":"2018-01-09T07:33:40.000Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-01-25T12:19:31.000Z","updated":"2018-01-09T07:39:34.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-01-25T12:19:31.000Z","updated":"2018-01-09T07:33:06.000Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-25T12:19:31.000Z","updated":"2018-01-09T07:39:08.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"阿里云服务器部署Node项目","slug":"阿里云服务器部署Node项目","date":"2018-10-09T01:53:41.000Z","updated":"2018-10-09T02:40:36.000Z","comments":true,"path":"2018/10/09/阿里云服务器部署Node项目/","link":"","permalink":"http://yoursite.com/2018/10/09/阿里云服务器部署Node项目/","excerpt":"","text":"一、远程登录服务器1.1 ssh 远程登录服务器123456789101112131415161718192021222324252627282930# 环境阿里云服务器操作系统： Ubuntu 14.04 64位 本地： MacOS# ssh 登录ssh root@47.xx.xx.xx (ip)# 接着，输入密码（购买服务器时的密码）******### 1.2 配置 root 及应用账号权限用户定制: 为了提高服务器安全性，需要设置一个高权限的账号来代替root执行常规操作```bash# 增加用户adduser shel # shel 为自定义用户名，然后输入密码，创建完成# 用户授权gpasswd -a tanya sudo # 添加用户到 sudo 组中sudo visudo # 打开后在文件此处新增一条# User privilege specificationroot ALL=(ALL:ALL) ALLshel ALL=(ALL:ALL) ALL# 重新开启一个终端，就可以以 shel 的身份登录啦ssh shel@47.xx.xx.xx # 然后输入密码，即可登录成功 1.3 配置本地无密码 ssh 登录 本地用户：/Users/shel 服务器用户：/home/shel 需要开启两个终端：一个服务器终端，一个本地终端 本地终端 12345678910# cd ~/.ssh # 进入到 .ssh目录# 生成 ssh key (之前用过github应该生成过key 无需再生成)ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.com\" # 会在本地 ~/.ssh 目录中生成两个文件 id_rsa id_rsa.pub，当然你也可以进行重命名# 开启 ssh 代理eval \"$(ssh-agent -s)\"# 把生成的私钥文件加到代理中ssh-add ~/.ssh/id_rsa # tanya_id_rsa 是重命名过的文件 服务器终端 12345678910111213141516# 把生成的公钥文件`id_rsa.pub`的内容放到服务器上 authorized_keys 文件中，并授权cd ~/.ssh # 进入到 .ssh目录sudo vi authorized_keys # 编辑 authorized_keys，添加 `id_rsa.pub` 内容，保存退出chmod 600 authorized_keys # 授权 authorized_keys 文件# 重启服务器 ssh 服务sudo service ssh restart# 重新开启一个终端ssh shel@47.xx.xx.xx # 无需输入密码，即可登录成功如果仍然需要密码 编辑 sudo vi /etc/ssh/sshd_config设置 PasswordAuthentication no 二、增强服务器安全等级2.1 修改服务器默认登录端口1234567891011121314# 编辑文件sudo vi /etc/ssh/sshd_config# 修改 Port 项，端口范围 0 ~ 65536Port xx# 在末尾添加AllowUsers shel# 重启服务sudo service ssh restart# 重新开启一个终端：ssh -p 端口 shel@47.xx.xx.xxssh -p xx shel@47.xx.xx.xx 有可能登录不上去，需要去阿里云控制台修改安全组规则，把你的端口加进去。 2.2 配置 iptables 和 Fail2Ban 增强安全防护2.2.1 配置 iptables：12345678# 升级更新一下系统sudo apt-get update &amp;&amp; sudo apt-get upgrade# 清空 iptablessudo iptables -F# 新建 iptables 规则配置文件sudo vi /etc/iptables.up.rules iptables.up.rules 配置， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748*filter# allow all connections-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# allow out traffic-A OUTPUT -j ACCEPT# allow http https-A INPUT -p tcp --dport 443 -j ACCEPT-A INPUT -p tcp --dport 80 -j ACCEPT# allow ssh port login-A INPUT -p tcp -m state --state NEW --dport 39999 -j ACCEPT# ping-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT# Mongodb 连接-A INPUT -s 127.0.0.1 -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT# 服务器 Node.js 端口开放，可以添加很多，只需修改一下 --destination-port 和 --source-port 就行了-A INPUT -s 127.0.0.1 -p tcp --destination-port 3000 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 3000 -m state --state ESTABLISHED -j ACCEPT-A INPUT -s 127.0.0.1 -p tcp --destination-port 3001 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 3001 -m state --state ESTABLISHED -j ACCEPT-A INPUT -s 127.0.0.1 -p tcp --destination-port 3002 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 3002 -m state --state ESTABLISHED -j ACCEPT# ...# Mysql 连接-A INPUT -s 127.0.0.1 -p tcp --destination-port 3306 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 3306 -m state --state ESTABLISHED -j ACCEPT# log denied calls-A INPUT -m limit --limit 5/min -j LOG --log-prefix \"iptables denied:\" --log-level 7# drop incoming sensitive connections-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --set-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --update --seconds 60 --hitcount 150 -j DROP# reject all other inbound-A INPUT -j REJECT-A FORWARD -j REJECTCOMMIT 接着， 12345# 查看防火墙状态sudo ufw status# 激活防火墙sudo ufw enable 开机启动防火墙脚本， 12#!/bin/shiptables-restore /etc/iptables.up.rules 执行脚本， 1sudo chmod +x /etc/network/if-up.d/iptables 2.2.2 配置 Fail2Ban：1234567891011# 安装 fail2bansudo apt-get install fail2ban# 查看 fail2ban 状态sudo service fail2ban status# 停止 fail2bansudo service fail2ban stop# 开启 fail2bansudo service fail2ban start 三、搭建 Nodejs 生产环境3.1 搭建服务器的 Nodejs 环境1234567891011121314151617181920212223# 更新服务器sudo apt-get update# 安装工具sudo apt-get install vim openssl build-essential libssl-dev wget curl git# 安装 nvm (node 版本管理工具) https://github.com/creationix/nvmwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.7/install.sh | bash# 安装 Node.js (我安装的版本) https://nodejs.org/en/nvm install v8.1.3# 指定 Node.js 版本nvm use v8.1.3# 安装 cnpmnpm --registry=https://registry.npm.taobao.org install -g npm# 如果有多个 Node.js 版本，通过这种方式指定默认版本nvm alias default v8.9.3# 增加系统文件监控数目echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 3.2 借助 pm2 让 Node.js 服务常驻1234567891011# 启动服务pm2 start app.js# 查看所有服务pm2 list# 查看应用pm2 show app# 查看日志pm2 logs 四、配置 Nginx 实现反向代理配置 Nginx 反向代理 Nodejs 端口安装 nginx 1sudo apt-get install nginx nginx 配置规则：可以通过 http://47.xx.xx.xx 访问服务器 http://127.0.0.1:8081 端口的服务 123456789101112131415161718upstream gusaifei &#123; server 127.0.0.1:8081;&#125;server &#123; listen 80; server_name 47.xx.xx.xx; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://gusaifei; proxy_redirect off; &#125;&#125; 重启之前，可以先检测一下配置规则 1sudo nginx -t 重启 nginx 服务 1sudo nginx -s reload 五、服务器配置安装 MongoDB5.1 在 Ubuntu 14.04 上安装 MongoDB12345678910# 安装，https://docs.mongodb.com/v3.4/tutorial/install-mongodb-on-ubuntu/# 开启服务sudo service mongod start# 停止服务sudo service mognod stop# 重启服务sudo service mongod restart 5.2 修改 MongoDB 默认端口123456789# 编辑配置文件sudo vi /etc/mongod.conf# 修改 Port 项，端口范围 0 ~ 65536net: port: xx# 重启服务sudo service mongod restart 5.3 往线上 MongoDB 导入单表数据或数据库如果已经修改过端口，需要把 27017 换成修改的端口。 1234567891011121314151617181920212223# 导出数据库：mongodump -h ip:端口 -d 数据库名 -o 输出文件夹名mongodump -h 127.0.0.1:27017 -d movie -o movie-backup# 压缩文件： tar zcvf 打包成的文件名 要打包的文件tar zcvf movie.tar.gz movie-backup# 上传文件到服务器： scp -P 端口号 本地压缩包 上传的服务器路径scp -P xx ~/Desktop/mooc/movie.tar.gz root@47.xx.xx.xx:/home/tanya/dbbackup# 解压文件：tar xvf 要解压的文件tar xvf movie.tar.gz# 导入数据库：mongorestore --host ip:端口 -d 数据库名 要导入的文件存放的位置mongorestore --host 127.0.0.1:27017 -d movie ./dbbackup/movie-backup/movie# 导出单表数据：mongoexport -d 数据库名 -c 表名 -q 查询条件 -o 输出文件名mongoexport -d dream-wall -c dreams -q '&#123;&#125;' -o dreams.json# 导入单表数据：mongoimport --host ip:端口 -d 数据库名 -c 表名 要导入的文件mongoimport --host 127.0.0.1:27017 -d dream-wall -c dreams ./dreams.json# 删除数据库mongo --host 127.0.0.1:27017 dream-wall --eval \"db.dropDatabase()\" 5.4 往线上 MySQL 导入单表数据或数据库（新增）123456# 导入数据库source ./dream-wall.sqlmysql -u root -p dream-wall &lt; dream-wall-backup.sql# 导出数据库mysqldump -u root -p dream-wall &gt; dream-wall-backup.sql 5.5 为上线项目配置 MongoDB 数据库读写权限创建用户及授权 123456789101112131415161718192021222324# 切换到 admin 数据库use admin# 创建用户db.createUser(&#123;user: 'tanya', pwd: 'tanya', roles: [&#123;role: 'userAdminAnyDatabase', db: 'admin'&#125;]&#125;)# 授权db.auth('tanya', 'tanya')# 切换到其他数据库use dream-wall# 创建用户db.createUser(&#123;user: 'tanya_dream-wall_runner', pwd: 'tanya', roles: [&#123;role: 'readWrite', db: 'dream-wall'&#125;]&#125;)db.createUser(&#123;user: 'tanya_dream-wall_wheel', pwd: 'tanya', roles: [&#123;role: 'read', db: 'dream-wall'&#125;]&#125;)# 修改配置，开启授权sudo vi /etc/mongod.confsecurity: authorization: 'enabled'# 重启 mongo 服务，使配置生效sudo service mongod restart 需要注意的是：每次要进行数据库操作都需要先进行授权 db.auth(&#39;tanya&#39;, &#39;tanya&#39;) 123456# 登录到指定数据库，无需授权mongo 127.0.0.1:xx/dream-wall -u tanya_dream-wall_runner -p tanya# 验证一下show tablesdb.dreams.find() 5.6 从一台服务器迁移数据到另一个线上 MongoDB 中就是数据库数据的导入和导出操作 1234567891011121314151617# 导出数据库：mongodump -h ip:端口 -d 数据库名 -u 用户名 -p 密码 -o 要输出的文件名mongodump -h 127.0.0.1:19999 -d dream-wall -u tanya_dream-wall_wheel -p tanya -o dream-wall-old# 导出单表：-h ip:端口 -d 数据库名 -u 用户名 -p 密码 -c 要导出的表 要输出的文件名mongoexport -h 127.0.0.1:19999 -d dream-wall -u tanya_dream-wall_wheel -p tanya -c dreams -q '&#123;&#125;' -o dream-wall-dreams-old.json# 下载到本地scp -P 39999 root@47.xx.xx.xx:/home/tanya/db/dream-wall-old.tar.gz ./# 导入数据库：mongorestore -h ip:端口 -d 数据库名 -u 用户名 -p 密码 要导入的文件名mongorestore -h 127.0.0.1:19999 -d dream-wall -u tanya_dream-wall_wheel -p tanya dream-wall-old# 导入单表：mongoimport -h ip:端口 -d 数据库名 -u 用户名 -p 密码 -c 要导入到的表 要导入的文件名mongoimport -h 127.0.0.1:19999 -d dream-wall -u tanya_dream-wall_wheel -p tanya -c dreams dream-wall-dreams-old.json# 下载文件到本地scp -P xx root@47.xx.xx.xx:/home/xx/dbbackup ./ 5.7 为数据库实现定时备份方案备份脚本 123456789101112131415161718192021222324#!/bin/sh# 存放目录backUpFolder=/home/tanya/backup/dream-wall# 为目录名增加备份时间date_now=`date +%Y_%m_%d_%H%M`# 目录名backFileName=dream-wall_$date_now# 进入到目录，并创建目录cd $backUpFoldermkdir -p $backFileName# 导出到目录中mongodump -h 127.0.0.1:xx -d dream-wall -u tanya_dream-wall_wheel -p tanya -o $backFileName# 压缩tar zcvf $backFileName.tar.gz $backFileName# 上传到七牛云NODE_ENV=$backUpFolder@$backFileName node /home/tanya/tasks/upload.js# 删除目录rm -rf $backFileName 定时任务 1234# 配置定时任务crontab -e00 4 * * * sh /home/tanya/tasks/dream-wall.backup.sh 注意啦：如果遇到上传七牛云失败的问题：把 node 路径补全就行了 1NODE_ENV=$backUpFolder@$backFileName /home/tanya/.nvm/versions/node/v8.9.3/bin/node /home/tanya/tasks/upload.js 5.8 上传到数据库备份到七牛云你需要先在七牛云上创建存储的空间及找到你的公钥和私钥。并在备份脚本中传入 QINIU_BUCKET、QINIU_ACCESS_KEY、QINIU_SECRET_KEY，修改一下上面的备份脚本 1NODE_ENV=$backUpFolder@$backFileName QINIU_BUCKET=空间名称 QINIU_ACCESS_KEY=你的公钥 QINIU_SECRET_KEY=你的私钥 node /home/tanya/tasks/upload.js 1234567891011121314151617181920212223242526272829303132333435363738const qiniu = require(\"qiniu\");const parts = process.env.NODE_ENV.split('@'); // 文件夹@文件名const file = parts[1] + '.tar.gz';const filePath = parts[0] + '/' + file;var bucket = process.env.QINIU_BUCKET; // 空间var accessKey = process.env.QINIU_ACCESS_KEY; // 公钥var secretKey = process.env.QINIU_SECRET_KEY; // 私钥console.log(accessKey, secretKey)var mac = new qiniu.auth.digest.Mac(accessKey, secretKey);var options = &#123; scope: bucket, saveKey: file&#125;var putPolicy = new qiniu.rs.PutPolicy(options);var uploadToken = putPolicy.uploadToken(mac);var config = new qiniu.conf.Config();var localFile = filePath;//config.zone = qiniu.zone.Zone_z0;var formUploader = new qiniu.form_up.FormUploader(config);var putExtra = new qiniu.form_up.PutExtra();//fileformUploader.putFile(uploadToken, null, localFile, putExtra, function(respErr, respBody, respInfo) &#123; if (respErr) &#123; throw respErr; &#125; if (respInfo.statusCode == 200) &#123; console.log(respBody); &#125; else &#123; console.log(respInfo.statusCode); console.log(respBody); &#125;&#125;); 六、向服务器正式部署和发布上线 Nodejs 项目6.1 上传项目代码到线上私有 Git 仓库你需要了解一下 git 基本操作： 1234567891011# 关联远程仓库git remote add origin 远程仓库地址# 添加所有文件git add .# 提交git commit -m 'init'# 推送到远程仓库git push origin -u master 6.2 配置 PM2 一键部署线上项目结构 pm2 文档：http://pm2.keymetrics.io/docs/usage/deployment/ pm2 配置文件 ecosystem.json 1234567891011121314151617181920212223242526272829&#123; \"apps\": [ &#123; \"name\": \"dream-wall-koa\", // 应用名称 \"script\": \"server.js\", // 启动脚本 \"env\": &#123; // 环境变量 \"COMMON_VARIABLE\": \"true\" &#125;, \"env_production\": &#123; // 生产环境变量 \"NODE_ENV\": \"production\" &#125; &#125; ], \"deploy\": &#123; \"production\": &#123; \"user\": \"tanya\", // 用户名 \"host\": [\"47.xx.xx.xx\"], // 主机 \"port\": \"39999\", // 端口 \"ref\": \"origin/master\", // 分支 \"repo\": \"git@gitee.com:drem-wall/dream-wall-koa.git\", // 仓库地址 \"path\": \"/home/shel/www/dream-wall-koa/production\", // 上传到服务器的目录 /www/dream-wall-koa \"ssh_options\": \"StrictHostKeyChecking=no\", \"post-deploy\": \"npm install --registry=https://registry.npm.taobao.org &amp;&amp; pm2 startOrRestart ecosystem.json --env production\", // 上传完成后执行的操作：安装依赖、启动 pm2 \"env\": &#123; \"NODE_ENV\": \"production\" &#125; &#125; &#125;&#125; 创建文件夹并授权 12345678# 进入到 www 目录cd /www# 创建文件夹sudo mkdir dream-wall-koa# 授权文件夹sudo chmod 777 dream-wall-koa 部署项目到服务器 12345# 安装pm2 deploy ecosystem.json production setup# 发布pm2 deploy ecosystem.json production 发布时报错：pm2：command not found 原因是：pm2 是非交互的操作方式 解决方式：打开 ~/.bashrc， 注释掉最上面的几行 12345# If not running interactively, don't do anything#case $- in# *i*) ;;# *) return;;#esac","categories":[],"tags":[]},{"title":"算法的时间复杂度","slug":"算法的时间复杂度","date":"2018-04-15T01:19:10.000Z","updated":"2018-04-15T04:58:58.000Z","comments":true,"path":"2018/04/15/算法的时间复杂度/","link":"","permalink":"http://yoursite.com/2018/04/15/算法的时间复杂度/","excerpt":"","text":"算法的效率虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率。算法的效率主要由以下两个复杂度来评估：时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。 时间复杂度同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行时，效率均不同。所以，精确度量算法的执行时间没有太大意义。 一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。 计算规则（大o表示法）1.用常数1来取代运行时间中所有加法常数。2.修改后的运行次数函数中，只保留最高阶项3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。 例子1234567var num = 0;num += 10console.log(num)语句频度：f(n) = f(1) = 3时间复杂度：T(n) = O(f(n)) = O(3) = O(1)O(1)称为常数阶 123456789var num = 0,i,n; //执行1次for (i = 0;i &lt; n;i++)&#123; // n次 num++ //n次&#125;console.log(num) //1次语句频度：f(n) = 1+n+n+1时间复杂度：T(n) = O(f(n)) = O(2n+2) = O(n)O(n)称为线性阶 123456789101112var num = 0,i,j,n,m; //执行1次for (i = 0;i &lt; n;i++)&#123; // n次 for (j = 0;j &lt; m;i++)&#123; // n*m次 num++ //n*m次&#125; console.log(num) //n次&#125;语句频度：f(n) = 2mn+2n+1如果 m=n, f(n) = 2n²+2n+1时间复杂度：T(n) = O(f(n)) = O(2n²+2n+1) = O(n²)O(n)称为平方阶 再来一个相对较复杂的算法（以冒泡排序为例,依次递增）123456789101112131415function BubbleSort(arr) &#123; var i,j,temp,n = arr.length; // 1 for(i = 1; i&lt;n; i++) &#123; //n-1次 for(j = 0; j&lt;n-i; j++) &#123; //n-1+n-2+n-3 +...+1,n(n-1)/2次 if(arr[j] &gt; arr[j+1]) &#123; //n(n-1)/2次 temp = arr[j] //0或n(n-1)/2次 arr[j] = arr[j+1] //0或n(n-1)/2次 arr[j+1] = temp; //0或n(n-1)/2次 &#125; &#125; &#125;&#125;最好情况下(数据不发生交换) f(n) = n²最坏情况下(数据都发生交换) f(n) = 5/2n²-3/2nT(n)最好 = T(n)最坏 = O(n²) 除了常数阶、线性阶、平方阶，还有如下时间复杂度：f(n)=nlogn时，时间复杂度为O(nlogn)，可以称为nlogn阶。f(n)=n³时，时间复杂度为O(n³)，可以称为立方阶。f(n)=2ⁿ时，时间复杂度为O(2ⁿ)，可以称为指数阶。f(n)=n!时，时间复杂度为O(n!)，可以称为阶乘阶。f(n)=(√n时，时间复杂度为O(√n)，可以称为平方根阶。复杂度直观图：","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}],"tags":[]},{"title":"完美的数组去重方法","slug":"完美的数组去重方法","date":"2018-02-12T14:32:10.000Z","updated":"2018-02-12T16:05:03.000Z","comments":true,"path":"2018/02/12/完美的数组去重方法/","link":"","permalink":"http://yoursite.com/2018/02/12/完美的数组去重方法/","excerpt":"","text":"数组去重的方法众多，最原始的方法就是双层循环来一一判断，当然我们可以用es5方法来简化写法，代码如下：123456789101112131415161718192021function unique(array) &#123; var res = []; for (var i = 0, len = array.length; i &lt; len; i++) &#123; var current = array[i]; if (res.indexOf(current) === -1) &#123; res.push(current) &#125; &#125; return res;&#125;// 用filter进一步简化function uniqe(arr) &#123; var res = arr.filter((item,index,arr) =&gt; &#123; return arr.indexOf(item) === index &#125;) return res &#125;var arr = [null,null,NaN,1,'1',1,1,0,[1],[2],[1],&#123;name:\"shel\"&#125;,&#123;name:'shel'&#125;] console.log(uniqe(arr)) // \b[null,1, \"1\", 0, [1], [2], [1], &#123;name:\"shel\"&#125;, &#123;name:\"shel\"&#125;]` 方法存在缺陷 ，无法对引用类型作判断，而且会忽略NaN 利用Object\b 这种方法是利用一个空的 Object 对象， 我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true， 在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。示例代码如下： 123456function unique(array) &#123; var obj = &#123;&#125;; return array.filter(function(item, index, array)&#123; return obj.hasOwnProperty(item) ? false : (obj[item] = true) &#125;)&#125; 我们可以发现，是有问题的，因为 1 和 ‘1’ 是不同的， 但是这种方法会判断为同一个值，这是因为对象的键值只能是字符串， 所以我们可以使用 typeof item + item 拼成字符串作为 key 值来避免这个问题：123456function unique(array) &#123; var obj = &#123;&#125;; return array.filter(function(item, index, array)&#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) &#125;)&#125; 然而，即便如此，我们依然无法正确区分出两个对象， 比如 {value: 1} 和 {value: 2}， 因为 typeof item + item 的结果都会是 object[object Object]， 不过我们可以使用 JSON.stringify 将对象序列化： 1234567891011function unique(array) &#123; var obj = &#123;&#125;; return array.filter(function(item, index, array)&#123; console.log(typeof item + JSON.stringify(item)) return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true) &#125;)&#125;var arr = [null,null,NaN,1,'1',1,1,0,[1],[2],[1],&#123;name:\"shel\"&#125;,&#123;name:'shel'&#125;] console.log(uniqe(arr))// \b[null,NaN,1, \"1\", 0, [1], [2], &#123;name:\"shel\"&#125;] ` 全部去重了 ES6随着 ES6 的到来，我们可以使用 Set 和 Map 数据结构，以 Set 为例 1234567 var arr = [null,null,NaN,1,'1',1,1,0,[1],[2],[1],&#123;name:\"shel\"&#125;,&#123;name:'shel'&#125;]function unique(array) &#123; return Array.from(new Set(array));&#125;console.log(unique(array)); // [null,NaN,1, \"1\", 0, [1], [2],[1], &#123;name:\"shel\"&#125;,&#123;name:\"shel\"&#125;] 对于引用类型无法去重","categories":[{"name":"utils","slug":"utils","permalink":"http://yoursite.com/categories/utils/"}],"tags":[]},{"title":"JavaScript设计模式(观察者模式)","slug":"JavaScript设计模式(观察者模式)","date":"2018-01-25T06:52:02.000Z","updated":"2018-01-27T05:41:32.000Z","comments":true,"path":"2018/01/25/JavaScript设计模式(观察者模式)/","link":"","permalink":"http://yoursite.com/2018/01/25/JavaScript设计模式(观察者模式)/","excerpt":"","text":"概念不多说 假设这样一个场景,在一个项目开发中，工程师A 写了这样一个导航栏模块,导航栏上有一个消息提示功能,根据获取的数据来展示提示数目1234567891011&lt;div id='nav'&gt;&lt;span id=\"messageNum\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var A = (function () &#123; var msg = document.getElementById('messageNum') function render() &#123; var ajaxNum = 5 msg.innerHTML = ajaxNum &#125; render() &#125;)()&lt;/script&gt; 这时候项目中需要新增一个用户评论功能模块，每提交一次评论 导航栏的消息提示+1，模块由B工程师写，由于两个模块被写在了不同的闭包模块中，并且B工程师又不想把模块糅合在一起(代码过于耦合)1234567&lt;button id='btn' value='add'&gt;&lt;/button&gt; var B = (function () &#123; var btn = document.getElementById('btn') btn.addEventListener('click', function () &#123; ... &#125;) &#125;)() 实现模式代码12345678910111213141516171819202122232425262728293031 var Observer =(function()&#123;// 事件池 缓存所有时间 var events = &#123;&#125;;// 事件挂载function regist(evt, handler)&#123;events[evt] = events[evt] || [];events[evt].push(&#123; handler:handler&#125;);&#125;// 事件触发function fire(evt, args)&#123; if(!events[evt])&#123; return; &#125; for(var i=0;i&lt;events[evt].length;i++)&#123; events[evt][i].handler(args); &#125;&#125;// 事件移除function off(evt)&#123; delete events[evt]&#125;return &#123; regist: regist, fire: fire, off: off&#125;&#125;)(); 改造后的代码123456789101112131415161718192021222324252627 &lt;div id='nav'&gt;&lt;span id=\"messageNum\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;script&gt; var A = (function () &#123; var msg = document.getElementById('messageNum') function render() &#123; var ajaxNum = 5 msg.innerHTML = ajaxNum &#125; // 增加消息功能 function addMessage(n) &#123; var num = msg.innerHTML num =parseInt(num) + n msg.innerHTML = num &#125; render() Observer.regist('increase',addMessage) // 订阅功能 &#125;)() &lt;/script&gt;&lt;button id='btn' value='add'&gt;&lt;/button&gt; var B = (function () &#123; var btn = document.getElementById('btn') btn.addEventListener('click', function () &#123; Observer.fire('increase',1) // 发布 &#125;) &#125;)() 总结 取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2018-01-09T08:25:02.000Z","updated":"2018-01-09T08:25:02.000Z","comments":true,"path":"2018/01/09/浏览器缓存/","link":"","permalink":"http://yoursite.com/2018/01/09/浏览器缓存/","excerpt":"","text":"浏览器缓存分为强缓存和协商缓存：1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器； 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源； 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。 强缓存原理强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。 Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是： 1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header，如： 2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）； 3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。 4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header，如： 2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来； 3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。 4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。 当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires #####协商缓存当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。【Last-Modified，If-Modified-Since】的控制缓存的原理是：1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间： 2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值： 3）服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header： 4）浏览器收到304的响应后，就会从缓存中加载资源。 5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。 【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题： 2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值： 3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化： 4）浏览器收到304的响应后，就会从缓存中加载资源。","categories":[],"tags":[]},{"title":"原生js实现组件系列","slug":"从简书迁移部分Blog至Hexo","date":"2018-01-09T08:23:54.000Z","updated":"2018-03-10T06:12:51.000Z","comments":true,"path":"2018/01/09/从简书迁移部分Blog至Hexo/","link":"","permalink":"http://yoursite.com/2018/01/09/从简书迁移部分Blog至Hexo/","excerpt":"","text":"源码地址","categories":[],"tags":[]},{"title":"深入理解闭包--内存","slug":"深入理解闭包--内存","date":"2018-01-09T06:52:34.000Z","updated":"2018-01-09T06:52:34.000Z","comments":true,"path":"2018/01/09/深入理解闭包--内存/","link":"","permalink":"http://yoursite.com/2018/01/09/深入理解闭包--内存/","excerpt":"","text":"内存（堆与栈）由于JavaScript存在垃圾自动回收机制，所以我们在开发中并不用像C和C++之类语言一样手动去跟踪内存使用情况，所以很多初学者就忽略了这个问题，但是我发现如果真的对内存空间一无所知，对理解一些JavaScript中的概念比如基本类型和引用数据类型的区别；比如浅拷贝与深拷贝什么不同？还有闭包，原型等是很模糊的。 JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以粗浅的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思路进行处理，比如JavaScript的在逻辑上实现了堆栈。因此理解堆栈数据结构的原理与特点任然十分重要。 栈的存取方式先进后出，后进先出（JavaScript中有5种基础数据类型，分别是Undefined、Null、Boolean、Number、String保存在栈内存中） 堆存取数据方式是无序的，但并不影响我们使用，就像JSON格式的数据，我们知道key就能准确拿到value（引用类型值（对象、数组、函数、正则）保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象。） 结合图实例理解 1234567891011 var num1 = 1; var num2= num1; //b赋值a,只是简单的数值的拷贝，他们相互独立，互不影响 num1=3; console.log(num2); //1var obj1 = &#123;name:'chris',age:'23'&#125;;var obj2 = obj1; obj1.name = 'xxx'; console.log(obj2); // &#123;name:'xxx',age:'23'&#125; // obj1赋给obj2的是指针（指向内存的地址），当地址指针相同时，尽管他 //们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。 执行上下文(Execution Context)执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval(不常用) 因此在一个JavaScript程序中，必定会产生多个执行上下文，JavaScript引擎会以堆栈的方式来处理它们，这个堆栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 结合图实例 首先是全局上下文入栈，然后执行代码，直到遇到read()，激活read函数并且创建了它自己的执行上下文 第二步read的执行上下文入栈，执行代码，遇到say(),激活say函数并且创建了它自己的执行上下 第三步say的执行上下文入栈，执行代码 第四步在say的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，say的上下文从栈中弹出。 第五步say的执行上下文弹出之后，继续执行readr的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样就只身下全局上下文了（关闭浏览器出栈） 12345678 function read() &#123; console.log(xxx) function say() &#123; console.log(xxx) &#125; say();&#125; read(); 一、基础概念回顾函数在被调用执行时，会创建一个当前函数的执行上下文。在该执行上下文的创建阶段，变量对象、作用域链、闭包、this指向会分别被确定。而一个JavaScript程序中一般来说会有多个函数，JavaScript引擎使用函数调用栈来管理这些函数的调用顺序。函数调用栈的调用顺序与栈数据结构一致。二、认识断点调试工具在尽量新版本的chrome浏览器中（不确定你用的老版本与我的一致），调出chrome浏览器的开发者工具。浏览器右上角竖着的三点 -&gt; 更多工具 -&gt; 开发者工具 -&gt; Sources 界面如图。断点调试界面 在我的demo中，我把代码放在app.js中，在index.html中引入。我们暂时只需要关注截图中红色箭头的地方。在最右侧上方，有一排图标。我们可以通过使用他们来控制函数的执行顺序。从左到右他们依次是：resume/pause script execution恢复/暂停脚本执行 step over next function call跨过，实际表现是不遇到函数时，执行下一步。遇到函数时，不进入函数直接执行下一步。 step into next function call跨入，实际表现是不遇到函数时，执行下一步。遇到到函数时，进入函数执行上下文。 step out of current function跳出当前函数 deactivate breakpoints停用断点 don‘t pause on exceptions不暂停异常捕获 其中跨过，跨入，跳出是我使用最多的三个操作。上图右侧第二个红色箭头指向的是函数调用栈（call Stack），这里会显示代码执行过程中，调用栈的变化。右侧第三个红色箭头指向的是作用域链（Scope），这里会显示当前函数的作用域链。其中Local表示当前的局部变量对象，Closure表示当前作用域链中的闭包。借助此处的作用域链展示，我们可以很直观的判断出一个例子中，到底谁是闭包，对于闭包的深入了解具有非常重要的帮助作用。三、断点设置在显示代码行数的地方点击，即可设置一个断点。断点设置有以下几个特点：在单独的变量声明(如果没有赋值)，函数声明的那一行，无法设置断点。 设置断点后刷新页面，JavaScript代码会执行到断点位置处暂停执行，然后我们就可以使用上边介绍过的几个操作开始调试了。 当你设置多个断点时，chrome工具会自动判断从最早执行的那个断点开始执行，因此我一般都是设置一个断点就行了。 四、实例接下来，我们借助一些实例，来使用断点调试工具，看一看，我们的demo函数，在执行过程中的具体表现。123456789101112131415 // demo01 var fn; function foo() &#123; var a = 2; function baz() &#123; console.log( a ); &#125; fn = baz; &#125;function bar() &#123; fn(); &#125;foo();bar(); // 2 在向下阅读之前，我们可以停下来思考一下，这个例子中，谁是闭包？这是来自《你不知道的js》中的一个例子。由于在使用断点调试过程中，发现chrome浏览器理解的闭包与该例子中所理解的闭包不太一致，因此专门挑出来，供大家参考。我个人更加倾向于chrome中的理解。第一步：设置断点，然后刷新页面。 设置断点 第二步：点击上图红色箭头指向的按钮（step into），该按钮的作用会根据代码执行顺序，一步一步向下执行。在点击的过程中，我们要注意观察下方call stack 与 scope的变化，以及函数执行位置的变化。 一步一步执行，当函数执行到上例子中baz函数被调用执行，foo形成了闭包 我们可以看到，在chrome工具的理解中，由于在foo内部声明的baz函数在调用时访问了它的变量a，因此foo成为了闭包。这好像和我们学习到的知识不太一样。我们来看看在《你不知道的js》这本书中的例子中的理解。你不知道的js中的例子 书中的注释可以明显的看出，作者认为fn为闭包。即baz，这和chrome工具中明显是不一样的。而在备受大家推崇的《JavaScript高级编程》一书中，是这样定义闭包。JavaScript高级编程中闭包的定义 书中作者将自己理解的闭包与包含函数所区分 这里chrome中理解的闭包，与我所阅读的这几本书中的理解的闭包不一样。具体这里我先不下结论，但是我心中更加偏向于相信chrome浏览器。我们修改一下demo01中的例子，来看看一个非常有意思的变化。12345678910111213141516 / / demo02 var fn; var m = 20;function foo() &#123; var a = 2;function baz(a) &#123; console.log(a);&#125;fn = baz; &#125;function bar() &#123; fn(m); &#125;foo();bar(); // 20 这个例子在demo01的基础上，我在baz函数中传入一个参数，并打印出来。在调用时，我将全局的变量m传入。输出结果变为20。在使用断点调试看看作用域链。闭包没了，作用域链中没有包含foo了。 是不是结果有点意外，闭包没了，作用域链中没有包含foo了。我靠，跟我们理解的好像又有点不一样。所以通过这个对比，我们可以确定闭包的形成需要两个条件。在函数内部创建新的函数；新的函数在执行时，访问了函数的变量对象； 还有更有意思的。我们继续来看看一个例子。123456789101112131415 // demo03 function foo() &#123; var a = 2; return function bar() &#123; var b = 9; return function fn() &#123; console.log(a); &#125; &#125;&#125;var bar = foo();var fn = bar();fn(); 在这个例子中，fn只访问了foo中的a变量，因此它的闭包只有foo。闭包只有foo 修改一下demo03，我们在fn中也访问bar中b变量试试看。12345678910111213141516 // demo04function foo() &#123; var a = 2;return function bar() &#123; var b = 9; return function fn() &#123; console.log(a, b); &#125; &#125;&#125;var bar = foo();var fn = bar();fn(); 这个时候闭包变成了两个 这个时候，闭包变成了两个。分别是bar，foo。我们知道，闭包在模块中的应用非常重要。因此，我们来一个模块的例子，也用断点工具来观察一下。12345678910111213141516171819202122232425262728 // demo05 (function() &#123;var a = 10;var b = 20;var test = &#123; m: 20, add: function(x) &#123; return a + x; &#125;, sum: function() &#123; return a + b + this.m; &#125;, mark: function(k, j) &#123; return k + j; &#125;&#125;window.test = test;&#125;)();test.add(100);test.sum();test.mark();var _mark = test.mark;_mark(); add执行时，闭包为外层的自执行函数，this指向test sum执行时，同上 mark执行时，闭包为外层的自执行函数，this指向test _mark执行时，闭包为外层的自执行函数，this指向window 注意：这里的this指向显示为Object或者Window，大写开头，他们表示的是实例的构造函数，实际上this是指向的具体实例test.mark能形成闭包，跟下面的补充例子（demo07）情况是一样的。 我们还可以结合点断调试的方式，来理解那些困扰我们很久的this指向。随时观察this的指向，在实际开发调试中非常有用。12345678910 var a = 10; var obj = &#123; a: 20&#125;function fn () &#123; console.log(this.a); &#125; fn.call(obj); // 20 this指向obj 补充一个例子12345678910111213// demo07 function foo() &#123; var a = 10; function fn1() &#123; return a; &#125; function fn2() &#123; return 10; &#125; fn2(); &#125; foo(); 这个例子，和其他例子不太一样。虽然fn2并没有访问到foo的变量，但是foo执行时仍然变成了闭包。而当我将fn1的声明去掉时，闭包便不会出现了。我暂时也不知道应该如何解释这种情况。只能大概知道与fn1有关，可能浏览器在实现时就认为只要存在访问上层作用域的可能性，就会被当成一个闭包吧。所以暂时就只能将它作为一个特例记住。更多的例子，大家可以自行尝试，总之，学会了使用断点调试之后，我们就能够很轻松的了解一段代码的执行过程了。这对快速定位错误，快速了解他人的代码都有非常巨大的帮助。大家一定要动手实践，把它给学会。最后，根据以上的摸索情况，再次总结一下闭包：闭包是在函数被调用执行的时候才被确认创建的。 闭包的形成，与作用域链的访问顺序有直接关系。 只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。","categories":[],"tags":[]}]}