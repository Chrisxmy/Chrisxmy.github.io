<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-09T02:40:36.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里云服务器部署Node项目</title>
    <link href="http://yoursite.com/2018/10/09/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Node%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2018/10/09/阿里云服务器部署Node项目/</id>
    <published>2018-10-09T01:53:41.000Z</published>
    <updated>2018-10-09T02:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、远程登录服务器"><a href="#一、远程登录服务器" class="headerlink" title="一、远程登录服务器"></a>一、远程登录服务器</h2><h3 id="1-1-ssh-远程登录服务器"><a href="#1-1-ssh-远程登录服务器" class="headerlink" title="1.1 ssh 远程登录服务器"></a>1.1 ssh 远程登录服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境</span></span><br><span class="line">阿里云服务器操作系统： Ubuntu 14.04 64位 </span><br><span class="line">本地： MacOS</span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh 登录</span></span><br><span class="line">ssh root@47.xx.xx.xx (ip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着，输入密码（购买服务器时的密码）</span></span><br><span class="line">******</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 1.2 配置 root 及应用账号权限</span></span><br><span class="line"></span><br><span class="line">用户定制: 为了提高服务器安全性，需要设置一个高权限的账号来代替root执行常规操作</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 增加用户</span></span><br><span class="line">adduser shel <span class="comment"># shel 为自定义用户名，然后输入密码，创建完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户授权</span></span><br><span class="line">gpasswd -a tanya sudo <span class="comment"># 添加用户到 sudo 组中</span></span><br><span class="line"></span><br><span class="line">sudo visudo <span class="comment"># 打开后在文件此处新增一条</span></span><br><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line">shel    ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新开启一个终端，就可以以 shel 的身份登录啦</span></span><br><span class="line">ssh shel@47.xx.xx.xx <span class="comment"># 然后输入密码，即可登录成功</span></span><br></pre></td></tr></table></figure><h3 id="1-3-配置本地无密码-ssh-登录"><a href="#1-3-配置本地无密码-ssh-登录" class="headerlink" title="1.3 配置本地无密码 ssh 登录"></a>1.3 配置本地无密码 ssh 登录</h3><ul><li>本地用户：<code>/Users/shel</code></li><li>服务器用户：<code>/home/shel</code></li></ul><p>需要开启两个终端：一个服务器终端，一个本地终端</p><p>本地终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/.ssh # 进入到 .ssh目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 ssh key (之前用过github应该生成过key 无需再生成)</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"xxx@xxx.com"</span> <span class="comment"># 会在本地 ~/.ssh 目录中生成两个文件 id_rsa id_rsa.pub，当然你也可以进行重命名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启 ssh 代理</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把生成的私钥文件加到代理中</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa <span class="comment"># tanya_id_rsa 是重命名过的文件</span></span><br></pre></td></tr></table></figure><p>服务器终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把生成的公钥文件`id_rsa.pub`的内容放到服务器上 authorized_keys 文件中，并授权</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh <span class="comment"># 进入到 .ssh目录</span></span><br><span class="line"></span><br><span class="line">sudo vi authorized_keys <span class="comment"># 编辑 authorized_keys，添加 `id_rsa.pub` 内容，保存退出</span></span><br><span class="line"></span><br><span class="line">chmod 600 authorized_keys <span class="comment"># 授权 authorized_keys 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务器 ssh 服务</span></span><br><span class="line">sudo service ssh restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新开启一个终端</span></span><br><span class="line">ssh shel@47.xx.xx.xx <span class="comment"># 无需输入密码，即可登录成功</span></span><br><span class="line"></span><br><span class="line">如果仍然需要密码 编辑 sudo vi /etc/ssh/sshd_config</span><br><span class="line">设置 PasswordAuthentication no</span><br></pre></td></tr></table></figure><h2 id="二、增强服务器安全等级"><a href="#二、增强服务器安全等级" class="headerlink" title="二、增强服务器安全等级"></a>二、增强服务器安全等级</h2><h3 id="2-1-修改服务器默认登录端口"><a href="#2-1-修改服务器默认登录端口" class="headerlink" title="2.1 修改服务器默认登录端口"></a>2.1 修改服务器默认登录端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line">sudo vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 Port 项，端口范围 0 ~ 65536</span></span><br><span class="line">Port xx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在末尾添加</span></span><br><span class="line">AllowUsers shel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo service ssh restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新开启一个终端：ssh -p 端口 shel@47.xx.xx.xx</span></span><br><span class="line">ssh -p xx shel@47.xx.xx.xx</span><br></pre></td></tr></table></figure><p>有可能登录不上去，需要去阿里云控制台修改安全组规则，把你的端口加进去。</p><h3 id="2-2-配置-iptables-和-Fail2Ban-增强安全防护"><a href="#2-2-配置-iptables-和-Fail2Ban-增强安全防护" class="headerlink" title="2.2 配置 iptables 和 Fail2Ban 增强安全防护"></a>2.2 配置 iptables 和 Fail2Ban 增强安全防护</h3><h4 id="2-2-1-配置-iptables："><a href="#2-2-1-配置-iptables：" class="headerlink" title="2.2.1 配置 iptables："></a>2.2.1 配置 iptables：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 升级更新一下系统</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空 iptables</span></span><br><span class="line">sudo iptables -F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 iptables 规则配置文件</span></span><br><span class="line">sudo vi /etc/iptables.up.rules</span><br></pre></td></tr></table></figure><p>iptables.up.rules 配置，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">*filter</span><br><span class="line"></span><br><span class="line"><span class="comment"># allow all connections</span></span><br><span class="line">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># allow out traffic</span></span><br><span class="line">-A OUTPUT -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># allow http https</span></span><br><span class="line">-A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># allow ssh port login</span></span><br><span class="line">-A INPUT -p tcp -m state --state NEW --dport 39999 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping</span></span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mongodb 连接</span></span><br><span class="line">-A INPUT -s 127.0.0.1 -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">-A OUTPUT -d 127.0.0.1 -p tcp --<span class="built_in">source</span>-port 27017 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器 Node.js 端口开放，可以添加很多，只需修改一下 --destination-port 和 --source-port 就行了</span></span><br><span class="line">-A INPUT -s 127.0.0.1 -p tcp --destination-port 3000 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">-A OUTPUT -d 127.0.0.1 -p tcp --<span class="built_in">source</span>-port 3000 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -s 127.0.0.1 -p tcp --destination-port 3001 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">-A OUTPUT -d 127.0.0.1 -p tcp --<span class="built_in">source</span>-port 3001 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -s 127.0.0.1 -p tcp --destination-port 3002 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">-A OUTPUT -d 127.0.0.1 -p tcp --<span class="built_in">source</span>-port 3002 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mysql 连接</span></span><br><span class="line">-A INPUT -s 127.0.0.1 -p tcp --destination-port 3306 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">-A OUTPUT -d 127.0.0.1 -p tcp --<span class="built_in">source</span>-port 3306 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># log denied calls</span></span><br><span class="line">-A INPUT -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 5/min -j LOG --<span class="built_in">log</span>-prefix <span class="string">"iptables denied:"</span> --<span class="built_in">log</span>-level 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># drop incoming sensitive connections</span></span><br><span class="line">-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --<span class="built_in">set</span></span><br><span class="line">-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --update --seconds 60 --hitcount 150 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># reject all other inbound</span></span><br><span class="line">-A INPUT -j REJECT</span><br><span class="line">-A FORWARD -j REJECT</span><br><span class="line"></span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>接着，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">sudo ufw status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活防火墙</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p>开机启动防火墙脚本，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">iptables-restore /etc/iptables.up.rules</span><br></pre></td></tr></table></figure><p>执行脚本，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/network/<span class="keyword">if</span>-up.d/iptables</span><br></pre></td></tr></table></figure><h4 id="2-2-2-配置-Fail2Ban："><a href="#2-2-2-配置-Fail2Ban：" class="headerlink" title="2.2.2 配置 Fail2Ban："></a>2.2.2 配置 Fail2Ban：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装  fail2ban</span></span><br><span class="line">sudo apt-get install fail2ban</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 fail2ban 状态</span></span><br><span class="line">sudo service fail2ban status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 fail2ban</span></span><br><span class="line">sudo service fail2ban stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启 fail2ban</span></span><br><span class="line">sudo service fail2ban start</span><br></pre></td></tr></table></figure><h2 id="三、搭建-Nodejs-生产环境"><a href="#三、搭建-Nodejs-生产环境" class="headerlink" title="三、搭建 Nodejs 生产环境"></a>三、搭建 Nodejs 生产环境</h2><h3 id="3-1-搭建服务器的-Nodejs-环境"><a href="#3-1-搭建服务器的-Nodejs-环境" class="headerlink" title="3.1 搭建服务器的 Nodejs 环境"></a>3.1 搭建服务器的 Nodejs 环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新服务器</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装工具</span></span><br><span class="line">sudo apt-get install vim openssl build-essential libssl-dev wget curl git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 nvm (node 版本管理工具) https://github.com/creationix/nvm</span></span><br><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.7/install.sh | bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Node.js (我安装的版本) https://nodejs.org/en/</span></span><br><span class="line">nvm install v8.1.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Node.js 版本</span></span><br><span class="line">nvm use v8.1.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 cnpm</span></span><br><span class="line">npm --registry=https://registry.npm.taobao.org install -g npm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有多个 Node.js 版本，通过这种方式指定默认版本</span></span><br><span class="line">nvm <span class="built_in">alias</span> default v8.9.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加系统文件监控数目</span></span><br><span class="line"><span class="built_in">echo</span> fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</span><br></pre></td></tr></table></figure><h3 id="3-2-借助-pm2-让-Node-js-服务常驻"><a href="#3-2-借助-pm2-让-Node-js-服务常驻" class="headerlink" title="3.2 借助 pm2 让 Node.js 服务常驻"></a>3.2 借助 pm2 让 Node.js 服务常驻</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">pm2 start app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有服务</span></span><br><span class="line">pm2 list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看应用</span></span><br><span class="line">pm2 show app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">pm2 logs</span><br></pre></td></tr></table></figure><h2 id="四、配置-Nginx-实现反向代理"><a href="#四、配置-Nginx-实现反向代理" class="headerlink" title="四、配置 Nginx 实现反向代理"></a>四、配置 Nginx 实现反向代理</h2><h3 id="配置-Nginx-反向代理-Nodejs-端口"><a href="#配置-Nginx-反向代理-Nodejs-端口" class="headerlink" title="配置 Nginx 反向代理 Nodejs 端口"></a>配置 Nginx 反向代理 Nodejs 端口</h3><p>安装 nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><p>nginx 配置规则：可以通过 <code>http://47.xx.xx.xx</code> 访问服务器 <code>http://127.0.0.1:8081</code> 端口的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream gusaifei &#123;</span><br><span class="line">    server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 47.xx.xx.xx;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forward-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">        proxy_set_header X-Nginx-Proxy <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://gusaifei;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启之前，可以先检测一下配置规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t</span><br></pre></td></tr></table></figure><p>重启 nginx 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="五、服务器配置安装-MongoDB"><a href="#五、服务器配置安装-MongoDB" class="headerlink" title="五、服务器配置安装 MongoDB"></a>五、服务器配置安装 MongoDB</h2><h3 id="5-1-在-Ubuntu-14-04-上安装-MongoDB"><a href="#5-1-在-Ubuntu-14-04-上安装-MongoDB" class="headerlink" title="5.1 在 Ubuntu 14.04 上安装 MongoDB"></a>5.1 在 Ubuntu 14.04 上安装 MongoDB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装，https://docs.mongodb.com/v3.4/tutorial/install-mongodb-on-ubuntu/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启服务</span></span><br><span class="line">sudo service mongod start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">sudo service mognod stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure><h3 id="5-2-修改-MongoDB-默认端口"><a href="#5-2-修改-MongoDB-默认端口" class="headerlink" title="5.2 修改 MongoDB 默认端口"></a>5.2 修改 MongoDB 默认端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">sudo vi /etc/mongod.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 Port 项，端口范围 0 ~ 65536</span></span><br><span class="line">net:</span><br><span class="line">  port: xx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure><h3 id="5-3-往线上-MongoDB-导入单表数据或数据库"><a href="#5-3-往线上-MongoDB-导入单表数据或数据库" class="headerlink" title="5.3 往线上 MongoDB 导入单表数据或数据库"></a>5.3 往线上 MongoDB 导入单表数据或数据库</h3><p>如果已经修改过端口，需要把 27017 换成修改的端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出数据库：mongodump -h ip:端口 -d 数据库名 -o 输出文件夹名</span></span><br><span class="line">mongodump -h 127.0.0.1:27017 -d movie -o movie-backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩文件： tar zcvf 打包成的文件名 要打包的文件</span></span><br><span class="line">tar zcvf movie.tar.gz movie-backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传文件到服务器： scp -P 端口号 本地压缩包 上传的服务器路径</span></span><br><span class="line">scp -P xx ~/Desktop/mooc/movie.tar.gz root@47.xx.xx.xx:/home/tanya/dbbackup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压文件：tar xvf 要解压的文件</span></span><br><span class="line">tar xvf movie.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据库：mongorestore --host ip:端口 -d 数据库名 要导入的文件存放的位置</span></span><br><span class="line">mongorestore --host 127.0.0.1:27017 -d movie ./dbbackup/movie-backup/movie</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出单表数据：mongoexport -d 数据库名 -c 表名 -q 查询条件 -o 输出文件名</span></span><br><span class="line">mongoexport -d dream-wall -c dreams -q <span class="string">'&#123;&#125;'</span> -o dreams.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入单表数据：mongoimport --host ip:端口 -d 数据库名 -c 表名 要导入的文件</span></span><br><span class="line">mongoimport --host 127.0.0.1:27017 -d dream-wall -c dreams ./dreams.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据库</span></span><br><span class="line">mongo --host 127.0.0.1:27017 dream-wall --<span class="built_in">eval</span> <span class="string">"db.dropDatabase()"</span></span><br></pre></td></tr></table></figure><h3 id="5-4-往线上-MySQL-导入单表数据或数据库（新增）"><a href="#5-4-往线上-MySQL-导入单表数据或数据库（新增）" class="headerlink" title="5.4 往线上 MySQL 导入单表数据或数据库（新增）"></a>5.4 往线上 MySQL 导入单表数据或数据库（新增）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入数据库</span></span><br><span class="line"><span class="built_in">source</span> ./dream-wall.sql</span><br><span class="line">mysql -u root -p dream-wall &lt; dream-wall-backup.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出数据库</span></span><br><span class="line">mysqldump -u root -p dream-wall &gt; dream-wall-backup.sql</span><br></pre></td></tr></table></figure><h3 id="5-5-为上线项目配置-MongoDB-数据库读写权限"><a href="#5-5-为上线项目配置-MongoDB-数据库读写权限" class="headerlink" title="5.5 为上线项目配置 MongoDB 数据库读写权限"></a>5.5 为上线项目配置 MongoDB 数据库读写权限</h3><p>创建用户及授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到 admin 数据库</span></span><br><span class="line">use admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">db.createUser(&#123;user: <span class="string">'tanya'</span>, <span class="built_in">pwd</span>: <span class="string">'tanya'</span>, roles: [&#123;role: <span class="string">'userAdminAnyDatabase'</span>, db: <span class="string">'admin'</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">db.auth(<span class="string">'tanya'</span>, <span class="string">'tanya'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到其他数据库</span></span><br><span class="line">use dream-wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">db.createUser(&#123;user: <span class="string">'tanya_dream-wall_runner'</span>, <span class="built_in">pwd</span>: <span class="string">'tanya'</span>, roles: [&#123;role: <span class="string">'readWrite'</span>, db: <span class="string">'dream-wall'</span>&#125;]&#125;)</span><br><span class="line">db.createUser(&#123;user: <span class="string">'tanya_dream-wall_wheel'</span>, <span class="built_in">pwd</span>: <span class="string">'tanya'</span>, roles: [&#123;role: <span class="string">'read'</span>, db: <span class="string">'dream-wall'</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置，开启授权</span></span><br><span class="line">sudo vi /etc/mongod.conf</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  authorization: <span class="string">'enabled'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 mongo 服务，使配置生效</span></span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure><p>需要注意的是：每次要进行数据库操作都需要先进行授权 <code>db.auth(&#39;tanya&#39;, &#39;tanya&#39;)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录到指定数据库，无需授权</span></span><br><span class="line">mongo 127.0.0.1:xx/dream-wall -u tanya_dream-wall_runner -p tanya</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证一下</span></span><br><span class="line">show tables</span><br><span class="line">db.dreams.find()</span><br></pre></td></tr></table></figure><h3 id="5-6-从一台服务器迁移数据到另一个线上-MongoDB-中"><a href="#5-6-从一台服务器迁移数据到另一个线上-MongoDB-中" class="headerlink" title="5.6 从一台服务器迁移数据到另一个线上 MongoDB 中"></a>5.6 从一台服务器迁移数据到另一个线上 MongoDB 中</h3><p>就是数据库数据的导入和导出操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出数据库：mongodump -h ip:端口 -d 数据库名 -u 用户名 -p 密码 -o 要输出的文件名</span></span><br><span class="line">mongodump -h 127.0.0.1:19999 -d dream-wall -u tanya_dream-wall_wheel -p tanya -o dream-wall-old</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出单表：-h ip:端口 -d 数据库名 -u 用户名 -p 密码 -c 要导出的表 要输出的文件名</span></span><br><span class="line">mongoexport -h 127.0.0.1:19999 -d dream-wall -u tanya_dream-wall_wheel -p tanya -c dreams -q <span class="string">'&#123;&#125;'</span> -o dream-wall-dreams-old.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载到本地</span></span><br><span class="line">scp -P 39999 root@47.xx.xx.xx:/home/tanya/db/dream-wall-old.tar.gz ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据库：mongorestore -h ip:端口 -d 数据库名 -u 用户名 -p 密码 要导入的文件名</span></span><br><span class="line">mongorestore -h 127.0.0.1:19999 -d dream-wall -u tanya_dream-wall_wheel -p tanya dream-wall-old</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入单表：mongoimport -h ip:端口 -d 数据库名 -u 用户名 -p 密码 -c 要导入到的表 要导入的文件名</span></span><br><span class="line">mongoimport -h 127.0.0.1:19999 -d dream-wall -u tanya_dream-wall_wheel -p tanya -c dreams dream-wall-dreams-old.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件到本地</span></span><br><span class="line">scp -P xx root@47.xx.xx.xx:/home/xx/dbbackup ./</span><br></pre></td></tr></table></figure><h3 id="5-7-为数据库实现定时备份方案"><a href="#5-7-为数据库实现定时备份方案" class="headerlink" title="5.7 为数据库实现定时备份方案"></a>5.7 为数据库实现定时备份方案</h3><p>备份脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存放目录</span></span><br><span class="line">backUpFolder=/home/tanya/backup/dream-wall</span><br><span class="line"><span class="comment"># 为目录名增加备份时间</span></span><br><span class="line">date_now=`date +%Y_%m_%d_%H%M`</span><br><span class="line"><span class="comment"># 目录名</span></span><br><span class="line">backFileName=dream-wall_<span class="variable">$date_now</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到目录，并创建目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$backUpFolder</span></span><br><span class="line">mkdir -p <span class="variable">$backFileName</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出到目录中</span></span><br><span class="line">mongodump -h 127.0.0.1:xx -d dream-wall -u tanya_dream-wall_wheel -p tanya -o <span class="variable">$backFileName</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩</span></span><br><span class="line">tar zcvf <span class="variable">$backFileName</span>.tar.gz <span class="variable">$backFileName</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传到七牛云</span></span><br><span class="line">NODE_ENV=<span class="variable">$backUpFolder</span>@<span class="variable">$backFileName</span> node /home/tanya/tasks/upload.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line">rm -rf <span class="variable">$backFileName</span></span><br></pre></td></tr></table></figure><p>定时任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置定时任务</span></span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">00 4 * * * sh /home/tanya/tasks/dream-wall.backup.sh</span><br></pre></td></tr></table></figure><p><strong>注意啦</strong>：如果遇到上传七牛云失败的问题：把 node 路径补全就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=<span class="variable">$backUpFolder</span>@<span class="variable">$backFileName</span> /home/tanya/.nvm/versions/node/v8.9.3/bin/node /home/tanya/tasks/upload.js</span><br></pre></td></tr></table></figure><h3 id="5-8-上传到数据库备份到七牛云"><a href="#5-8-上传到数据库备份到七牛云" class="headerlink" title="5.8 上传到数据库备份到七牛云"></a>5.8 上传到数据库备份到七牛云</h3><p>你需要先在七牛云上创建存储的空间及找到你的公钥和私钥。并在备份脚本中传入 QINIU_BUCKET、QINIU_ACCESS_KEY、QINIU_SECRET_KEY，修改一下上面的备份脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=<span class="variable">$backUpFolder</span>@<span class="variable">$backFileName</span> QINIU_BUCKET=空间名称 QINIU_ACCESS_KEY=你的公钥 QINIU_SECRET_KEY=你的私钥 node /home/tanya/tasks/upload.js</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qiniu = <span class="built_in">require</span>(<span class="string">"qiniu"</span>);</span><br><span class="line"><span class="keyword">const</span> parts = process.env.NODE_ENV.split(<span class="string">'@'</span>); <span class="comment">// 文件夹@文件名</span></span><br><span class="line"><span class="keyword">const</span> file = parts[<span class="number">1</span>] + <span class="string">'.tar.gz'</span>;</span><br><span class="line"><span class="keyword">const</span> filePath = parts[<span class="number">0</span>] + <span class="string">'/'</span> + file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bucket = process.env.QINIU_BUCKET; <span class="comment">// 空间</span></span><br><span class="line"><span class="keyword">var</span> accessKey = process.env.QINIU_ACCESS_KEY; <span class="comment">// 公钥</span></span><br><span class="line"><span class="keyword">var</span> secretKey = process.env.QINIU_SECRET_KEY; <span class="comment">// 私钥</span></span><br><span class="line"><span class="built_in">console</span>.log(accessKey, secretKey)</span><br><span class="line"><span class="keyword">var</span> mac = <span class="keyword">new</span> qiniu.auth.digest.Mac(accessKey, secretKey);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  scope: bucket,</span><br><span class="line">  saveKey: file</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> putPolicy = <span class="keyword">new</span> qiniu.rs.PutPolicy(options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uploadToken = putPolicy.uploadToken(mac);</span><br><span class="line"><span class="keyword">var</span> config = <span class="keyword">new</span> qiniu.conf.Config();</span><br><span class="line"><span class="keyword">var</span> localFile = filePath;</span><br><span class="line"></span><br><span class="line"><span class="comment">//config.zone = qiniu.zone.Zone_z0;</span></span><br><span class="line"><span class="keyword">var</span> formUploader = <span class="keyword">new</span> qiniu.form_up.FormUploader(config);</span><br><span class="line"><span class="keyword">var</span> putExtra = <span class="keyword">new</span> qiniu.form_up.PutExtra();</span><br><span class="line"></span><br><span class="line"><span class="comment">//file</span></span><br><span class="line">formUploader.putFile(uploadToken, <span class="literal">null</span>, localFile, putExtra, <span class="function"><span class="keyword">function</span>(<span class="params">respErr,</span></span></span><br><span class="line"><span class="function"><span class="params">  respBody, respInfo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (respErr) &#123;</span><br><span class="line">    <span class="keyword">throw</span> respErr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (respInfo.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(respBody);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(respInfo.statusCode);</span><br><span class="line">    <span class="built_in">console</span>.log(respBody);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="六、向服务器正式部署和发布上线-Nodejs-项目"><a href="#六、向服务器正式部署和发布上线-Nodejs-项目" class="headerlink" title="六、向服务器正式部署和发布上线 Nodejs 项目"></a>六、向服务器正式部署和发布上线 Nodejs 项目</h2><h3 id="6-1-上传项目代码到线上私有-Git-仓库"><a href="#6-1-上传项目代码到线上私有-Git-仓库" class="headerlink" title="6.1 上传项目代码到线上私有 Git 仓库"></a>6.1 上传项目代码到线上私有 Git 仓库</h3><p>你需要了解一下 git 基本操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关联远程仓库</span></span><br><span class="line">git remote add origin 远程仓库地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git commit -m <span class="string">'init'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">git push origin -u master</span><br></pre></td></tr></table></figure><h3 id="6-2-配置-PM2-一键部署线上项目结构"><a href="#6-2-配置-PM2-一键部署线上项目结构" class="headerlink" title="6.2 配置 PM2 一键部署线上项目结构"></a>6.2 配置 PM2 一键部署线上项目结构</h3><blockquote><p>pm2 文档：<a href="http://pm2.keymetrics.io/docs/usage/deployment/" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/deployment/</a></p></blockquote><p>pm2 配置文件 ecosystem.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"apps"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      "name": "dream-wall-koa", // 应用名称</span><br><span class="line">      "script": "server.js", // 启动脚本</span><br><span class="line">      "env": &#123; // 环境变量</span><br><span class="line">        "COMMON_VARIABLE": "true"</span><br><span class="line">      &#125;,</span><br><span class="line">      "env_production": &#123; // 生产环境变量</span><br><span class="line">        "NODE_ENV": "production"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "deploy": &#123;</span><br><span class="line">    "production": &#123;</span><br><span class="line">      "user": "tanya", // 用户名</span><br><span class="line">      "host": ["47.xx.xx.xx"], // 主机</span><br><span class="line">      "port": "39999", // 端口</span><br><span class="line">      "ref": "origin/master", // 分支</span><br><span class="line">      "repo": "git@gitee.com:drem-wall/dream-wall-koa.git", // 仓库地址</span><br><span class="line">      "path": "/home/shel/www/dream-wall-koa/production", // 上传到服务器的目录 /www/dream-wall-koa</span><br><span class="line">      "ssh_options": "StrictHostKeyChecking=no",</span><br><span class="line">      "post-deploy": "npm install --registry=https://registry.npm.taobao.org &amp;&amp; pm2 startOrRestart ecosystem.json --env production", // 上传完成后执行的操作：安装依赖、启动 pm2</span><br><span class="line">      "env": &#123;</span><br><span class="line">        "NODE_ENV": "production"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建文件夹并授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入到 www 目录</span></span><br><span class="line"><span class="built_in">cd</span> /www</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">sudo mkdir dream-wall-koa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权文件夹</span></span><br><span class="line">sudo chmod 777 dream-wall-koa</span><br></pre></td></tr></table></figure><p>部署项目到服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pm2 deploy ecosystem.json production setup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">pm2 deploy ecosystem.json production</span><br></pre></td></tr></table></figure><p>发布时报错：<code>pm2：command not found</code></p><p>原因是：pm2 是非交互的操作方式</p><p>解决方式：打开 <code>~/.bashrc</code>， 注释掉最上面的几行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If not running interactively, don't do anything</span></span><br><span class="line"><span class="comment">#case $- in</span></span><br><span class="line"><span class="comment">#    *i*) ;;</span></span><br><span class="line"><span class="comment">#      *) return;;</span></span><br><span class="line"><span class="comment">#esac</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、远程登录服务器&quot;&gt;&lt;a href=&quot;#一、远程登录服务器&quot; class=&quot;headerlink&quot; title=&quot;一、远程登录服务器&quot;&gt;&lt;/a&gt;一、远程登录服务器&lt;/h2&gt;&lt;h3 id=&quot;1-1-ssh-远程登录服务器&quot;&gt;&lt;a href=&quot;#1-1-ssh-远程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法的时间复杂度</title>
    <link href="http://yoursite.com/2018/04/15/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/04/15/算法的时间复杂度/</id>
    <published>2018-04-15T01:19:10.000Z</published>
    <updated>2018-04-15T04:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="算法的效率"><a href="#算法的效率" class="headerlink" title="算法的效率"></a>算法的效率</h4><p>虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率。算法的效率主要由以下两个复杂度来评估：时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。<br>设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行时，效率均不同。所以，精确度量算法的执行时间没有太大意义。 一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。</p><h4 id="计算规则（大o表示法）"><a href="#计算规则（大o表示法）" class="headerlink" title="计算规则（大o表示法）"></a>计算规则（大o表示法）</h4><p>1.用常数1来取代运行时间中所有加法常数。<br>2.修改后的运行次数函数中，只保留最高阶项<br>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">num += <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line"></span><br><span class="line">语句频度：f(n) = f(<span class="number">1</span>) = <span class="number">3</span></span><br><span class="line">时间复杂度：T(n) = O(f(n)) = O(<span class="number">3</span>) = O(<span class="number">1</span>)</span><br><span class="line">O(<span class="number">1</span>)称为常数阶</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>,i,n;     <span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n;i++)&#123;   <span class="comment">// n次</span></span><br><span class="line">    num++              <span class="comment">//n次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num)  <span class="comment">//1次</span></span><br><span class="line"></span><br><span class="line">语句频度：f(n) = <span class="number">1</span>+n+n+<span class="number">1</span></span><br><span class="line">时间复杂度：T(n) = O(f(n)) = O(<span class="number">2</span>n+<span class="number">2</span>) = O(n)</span><br><span class="line">O(n)称为线性阶</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>,i,j,n,m;     <span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n;i++)&#123;   <span class="comment">// n次</span></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; m;i++)&#123;   <span class="comment">// n*m次</span></span><br><span class="line">    num++              <span class="comment">//n*m次</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(num)  <span class="comment">//n次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">语句频度：f(n) = <span class="number">2</span>mn+<span class="number">2</span>n+<span class="number">1</span></span><br><span class="line">如果 m=n, f(n) = <span class="number">2</span>n²+<span class="number">2</span>n+<span class="number">1</span></span><br><span class="line">时间复杂度：T(n) = O(f(n)) = O(<span class="number">2</span>n²+<span class="number">2</span>n+<span class="number">1</span>) = O(n²)</span><br><span class="line">O(n)称为平方阶</span><br></pre></td></tr></table></figure><h5 id="再来一个相对较复杂的算法（以冒泡排序为例-依次递增）"><a href="#再来一个相对较复杂的算法（以冒泡排序为例-依次递增）" class="headerlink" title="再来一个相对较复杂的算法（以冒泡排序为例,依次递增）"></a>再来一个相对较复杂的算法（以冒泡排序为例,依次递增）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,j,temp,n = arr.length; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;n; i++) &#123;         <span class="comment">//n-1次</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j&lt;n-i; j++) &#123;   <span class="comment">//n-1+n-2+n-3 +...+1,n(n-1)/2次</span></span><br><span class="line">          <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;  <span class="comment">//n(n-1)/2次</span></span><br><span class="line">              temp = arr[j]        <span class="comment">//0或n(n-1)/2次</span></span><br><span class="line">              arr[j] = arr[j+<span class="number">1</span>]    <span class="comment">//0或n(n-1)/2次</span></span><br><span class="line">              arr[j+<span class="number">1</span>] = temp;     <span class="comment">//0或n(n-1)/2次</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">最好情况下(数据不发生交换) f(n) = n²</span><br><span class="line">最坏情况下(数据都发生交换) f(n) = <span class="number">5</span>/<span class="number">2</span>n²<span class="number">-3</span>/<span class="number">2</span>n</span><br><span class="line">T(n)最好 = T(n)最坏 = O(n²)</span><br></pre></td></tr></table></figure><p>除了常数阶、线性阶、平方阶，还有如下时间复杂度：f(n)=nlogn时，时间复杂度为O(nlogn)，可以称为nlogn阶。f(n)=n³时，时间复杂度为O(n³)，可以称为立方阶。f(n)=2ⁿ时，时间复杂度为O(2ⁿ)，可以称为指数阶。f(n)=n!时，时间复杂度为O(n!)，可以称为阶乘阶。f(n)=(√n时，时间复杂度为O(√n)，可以称为平方根阶。<br>复杂度直观图：<br><img src="https://upload-images.jianshu.io/upload_images/3984027-068272225e486a78.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="time.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;算法的效率&quot;&gt;&lt;a href=&quot;#算法的效率&quot; class=&quot;headerlink&quot; title=&quot;算法的效率&quot;&gt;&lt;/a&gt;算法的效率&lt;/h4&gt;&lt;p&gt;虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>完美的数组去重方法</title>
    <link href="http://yoursite.com/2018/02/12/%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/02/12/完美的数组去重方法/</id>
    <published>2018-02-12T14:32:10.000Z</published>
    <updated>2018-02-12T16:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>数组去重的方法众多，最原始的方法就是双层循环来一一判断，当然我们可以用es5方法来简化写法，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> current = array[i];</span><br><span class="line">        <span class="keyword">if</span> (res.indexOf(current) === <span class="number">-1</span>) &#123;</span><br><span class="line">            res.push(current)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用filter进一步简化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqe</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> res = arr.filter(<span class="function">(<span class="params">item,index,arr</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">NaN</span>,<span class="number">1</span>,<span class="string">'1'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>],&#123;<span class="attr">name</span>:<span class="string">"shel"</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'shel'</span>&#125;]</span><br><span class="line">  <span class="built_in">console</span>.log(uniqe(arr))</span><br><span class="line"> <span class="comment">// [null,1, "1", 0, [1], [2], [1], &#123;name:"shel"&#125;, &#123;name:"shel"&#125;]</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p><strong>方法存在缺陷 ，无法对引用类型作判断，而且会忽略NaN</strong></p><h3 id="利用Object"><a href="#利用Object" class="headerlink" title="利用Object"></a>利用Object</h3><p> 这种方法是利用一个空的 Object 对象，<br> 我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true，<br> 在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(item) ? <span class="literal">false</span> : (obj[item] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们可以发现，是有问题的，因为 1 和 ‘1’ 是不同的，<br> 但是这种方法会判断为同一个值，这是因为对象的键值只能是字符串，<br> 所以我们可以使用 typeof item + item 拼成字符串作为 key 值来避免这个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 然而，即便如此，我们依然无法正确区分出两个对象，<br> 比如 {value: 1} 和 {value: 2}，<br> 因为 typeof item + item 的结果都会是 object[object Object]，<br> 不过我们可以使用 JSON.stringify 将对象序列化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item))</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">NaN</span>,<span class="number">1</span>,<span class="string">'1'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>],&#123;<span class="attr">name</span>:<span class="string">"shel"</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'shel'</span>&#125;]</span><br><span class="line"> <span class="built_in">console</span>.log(uniqe(arr))</span><br><span class="line"><span class="comment">// [null,NaN,1, "1", 0, [1], [2], &#123;name:"shel"&#125;] </span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p> <strong>全部去重了</strong></p><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>随着 ES6 的到来，我们可以使用 Set 和 Map 数据结构，以 Set 为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">NaN</span>,<span class="number">1</span>,<span class="string">'1'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>],&#123;<span class="attr">name</span>:<span class="string">"shel"</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'shel'</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(array)); </span><br><span class="line"><span class="comment">// [null,NaN,1, "1", 0, [1], [2],[1], &#123;name:"shel"&#125;,&#123;name:"shel"&#125;]</span></span><br></pre></td></tr></table></figure><p><strong>对于引用类型无法去重</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组去重的方法众多，最原始的方法就是双层循环来一一判断，当然我们可以用es5方法来简化写法，代码如下：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="utils" scheme="http://yoursite.com/categories/utils/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式(观察者模式)</title>
    <link href="http://yoursite.com/2018/01/25/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)/"/>
    <id>http://yoursite.com/2018/01/25/JavaScript设计模式(观察者模式)/</id>
    <published>2018-01-25T06:52:02.000Z</published>
    <updated>2018-01-27T05:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>概念不多说</p><p>假设这样一个场景,在一个项目开发中，工程师A 写了这样一个导航栏模块,导航栏上有一个消息提示功能,根据获取的数据来展示提示数目<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">'nav'</span>&gt;&lt;span id="messageNum"&gt;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">          <span class="keyword">var</span> A = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'messageNum'</span>)        </span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;      </span><br><span class="line">              <span class="keyword">var</span> ajaxNum = <span class="number">5</span></span><br><span class="line">              msg.innerHTML = ajaxNum</span><br><span class="line">          &#125;    </span><br><span class="line">          render()</span><br><span class="line">      &#125;)()</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>这时候项目中需要新增一个用户评论功能模块，每提交一次评论 导航栏的消息提示+1，模块由B工程师写，由于两个模块被写在了不同的闭包模块中，并且B工程师又不想把模块糅合在一起(代码过于耦合)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">'btn'</span> value=<span class="string">'add'</span>&gt;&lt;/button&gt;</span><br><span class="line">     <span class="keyword">var</span> B = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">           btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;)()</span><br></pre></td></tr></table></figure></p><h2 id="实现模式代码"><a href="#实现模式代码" class="headerlink" title="实现模式代码"></a>实现模式代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> Observer =(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 事件池 缓存所有时间</span></span><br><span class="line">   <span class="keyword">var</span> events = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件挂载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">regist</span>(<span class="params">evt, handler</span>)</span>&#123;</span><br><span class="line">events[evt] = events[evt] || [];</span><br><span class="line">events[evt].push(&#123;</span><br><span class="line">    handler:handler</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件触发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fire</span>(<span class="params">evt, args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!events[evt])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;events[evt].length;i++)&#123;</span><br><span class="line">        events[evt][i].handler(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  事件移除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">off</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> events[evt]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    regist: regist,</span><br><span class="line">    fire: fire,</span><br><span class="line">    off: off</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="改造后的代码"><a href="#改造后的代码" class="headerlink" title="改造后的代码"></a>改造后的代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=<span class="string">'nav'</span>&gt;&lt;span id="messageNum"&gt;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">         <span class="keyword">var</span> A = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'messageNum'</span>)        </span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;      </span><br><span class="line">               <span class="keyword">var</span> ajaxNum = <span class="number">5</span></span><br><span class="line">               msg.innerHTML = ajaxNum</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 增加消息功能</span></span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">addMessage</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">var</span> num = msg.innerHTML </span><br><span class="line">               num =<span class="built_in">parseInt</span>(num) + n  </span><br><span class="line">               msg.innerHTML = num   </span><br><span class="line">           &#125;</span><br><span class="line">           render()</span><br><span class="line">           Observer.regist(<span class="string">'increase'</span>,addMessage) <span class="comment">// 订阅功能</span></span><br><span class="line"></span><br><span class="line">       &#125;)()</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;button id='btn' value='add'&gt;&lt;/</span>button&gt;</span><br><span class="line">     <span class="keyword">var</span> B = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">           btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                Observer.fire(<span class="string">'increase'</span>,<span class="number">1</span>)   <span class="comment">// 发布</span></span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;)()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起<br>虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;概念不多说&lt;/p&gt;
&lt;p&gt;假设这样一个场景,在一个项目开发中，工程师A 写了这样一个导航栏模块,导航栏上有一个消息提示功能,根据获取的数据来展示提示数目&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器缓存</title>
    <link href="http://yoursite.com/2018/01/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/01/09/浏览器缓存/</id>
    <published>2018-01-09T08:25:02.000Z</published>
    <updated>2018-01-09T08:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="浏览器缓存分为强缓存和协商缓存："><a href="#浏览器缓存分为强缓存和协商缓存：" class="headerlink" title="浏览器缓存分为强缓存和协商缓存："></a>浏览器缓存分为强缓存和协商缓存：</h5><p>1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；</p><p>2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p><p>3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p><p>4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p><h6 id="强缓存原理"><a href="#强缓存原理" class="headerlink" title="强缓存原理"></a>强缓存原理</h6><p>强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p><p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header，如：</p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-41c80c397f90cb54.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="捕获.PNG"></p><p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</p><p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</p><p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。<br>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：<br>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header，如：</p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-25cd6c93282af038.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="捕获1.PNG"></p><p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p><p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p><p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。<br>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p><p><strong>当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires</strong></p><p>#####协商缓存<br>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：<br><a href="http://images2015.cnblogs.com/blog/459873/201601/459873-20160115111431303-866314106.png" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3984027-619b86443b9ca398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a><br>查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：<br><a href="http://images2015.cnblogs.com/blog/459873/201601/459873-20160115111435100-1664945349.png" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3984027-c84a93be93458346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a><br>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。<br>【Last-Modified，If-Modified-Since】的控制缓存的原理是：<br>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间：</p><p><a href="http://images2015.cnblogs.com/blog/459873/201601/459873-20160115111438210-1551540589.png" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3984027-75f4726565315e82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a></p><p>2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：</p><p><a href="http://images2015.cnblogs.com/blog/459873/201601/459873-20160115125437460-1062702620.png" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3984027-07dc318ecc41d630.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无标题"></a></p><p>3）服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：<br><a href="http://images2015.cnblogs.com/blog/459873/201601/459873-20160115111450069-558396542.png" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3984027-af0d93ae62b49064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a></p><p>4）浏览器收到304的响应后，就会从缓存中加载资源。</p><p>5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p><p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：<br>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：</p><p><a href="http://images2015.cnblogs.com/blog/459873/201601/459873-20160115112627835-440813422.png" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3984027-fd76fb04f2b9ef8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a></p><p>2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：<br><a href="http://images2015.cnblogs.com/blog/459873/201601/459873-20160115112635850-559297790.png" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3984027-32f42ca3b8f02137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a></p><p>3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：<br><a href="http://images2015.cnblogs.com/blog/459873/201601/459873-20160115125438928-1048294855.png" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3984027-7d797665e30afb2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a></p><p>4）浏览器收到304的响应后，就会从缓存中加载资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;浏览器缓存分为强缓存和协商缓存：&quot;&gt;&lt;a href=&quot;#浏览器缓存分为强缓存和协商缓存：&quot; class=&quot;headerlink&quot; title=&quot;浏览器缓存分为强缓存和协商缓存：&quot;&gt;&lt;/a&gt;浏览器缓存分为强缓存和协商缓存：&lt;/h5&gt;&lt;p&gt;1）浏览器在加载资源时，先根
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>原生js实现组件系列</title>
    <link href="http://yoursite.com/2018/01/09/%E4%BB%8E%E7%AE%80%E4%B9%A6%E8%BF%81%E7%A7%BB%E9%83%A8%E5%88%86Blog%E8%87%B3Hexo/"/>
    <id>http://yoursite.com/2018/01/09/从简书迁移部分Blog至Hexo/</id>
    <published>2018-01-09T08:23:54.000Z</published>
    <updated>2018-03-10T06:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a><a href="https://github.com/Chrisxmy/wheels" target="_blank" rel="noopener">源码地址</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码地址&quot;&gt;&lt;a href=&quot;#源码地址&quot; class=&quot;headerlink&quot; title=&quot;源码地址&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Chrisxmy/wheels&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解闭包--内存</title>
    <link href="http://yoursite.com/2018/01/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85--%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2018/01/09/深入理解闭包--内存/</id>
    <published>2018-01-09T06:52:34.000Z</published>
    <updated>2018-01-09T06:52:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内存（堆与栈）"><a href="#内存（堆与栈）" class="headerlink" title="内存（堆与栈）"></a>内存（堆与栈）</h4><p>由于JavaScript存在垃圾自动回收机制，所以我们在开发中并不用像C和C++之类语言一样手动去跟踪内存使用情况，所以很多初学者就忽略了这个问题，但是我发现如果真的对内存空间一无所知，对理解一些JavaScript中的概念比如<strong>基本类型</strong>和<strong>引用数据类型</strong>的区别；比如<strong>浅拷贝</strong>与<strong>深拷贝</strong>什么不同？还有闭包，原型等是很模糊的。</p><p>JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以粗浅的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思路进行处理，比如JavaScript的在逻辑上实现了堆栈。因此理解堆栈数据结构的原理与特点任然十分重要。</p><ul><li>栈的存取方式<strong>先进后出，后进先出</strong>（JavaScript中有5种<strong>基础数据类型</strong>，分别是Undefined、Null、Boolean、Number、String保存在栈内存中）</li><li><p>堆存取数据方式是无序的，但并不影响我们使用，就像JSON格式的数据，我们知道key就能准确拿到value<br>（<strong>引用类型值</strong>（对象、数组、函数、正则）保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象。）</p><pre><code>结合图实例理解</code></pre></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/3984027-1bc5e79ab4f3ecb5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stack.PNG"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> num2= num1; <span class="comment">//b赋值a,只是简单的数值的拷贝，他们相互独立，互不影响</span></span><br><span class="line">    num1=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num2); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'chris'</span>,<span class="attr">age</span>:<span class="string">'23'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;                                            </span><br><span class="line">obj1.name = <span class="string">'xxx'</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(obj2); <span class="comment">//  &#123;name:'xxx',age:'23'&#125;</span></span><br><span class="line"> <span class="comment">// obj1赋给obj2的是指针（指向内存的地址），当地址指针相同时，尽管他   </span></span><br><span class="line"> <span class="comment">//们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。</span></span><br></pre></td></tr></table></figure></p><h3 id="执行上下文-Execution-Context"><a href="#执行上下文-Execution-Context" class="headerlink" title="执行上下文(Execution Context)"></a>执行上下文(Execution Context)</h3><p>执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。</p><ul><li><p>全局环境：JavaScript代码运行起来会首先进入该环境</p></li><li><p>函数环境：当函数被调用执行时，会进入当前函数中执行代码</p></li><li><p>eval(不常用)</p></li></ul><p>因此在一个JavaScript程序中，必定会产生多个执行上下文，JavaScript引擎会以堆栈的方式来处理它们，这个堆栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。<br>                                                                     结合图实例</p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-7765f35c0423c605.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="context.PNG"></p><p>首先是全局上下文入栈，然后执行代码，直到遇到read()，激活read函数并且创建了它自己的执行上下文</p><p>第二步read的执行上下文入栈，执行代码，遇到say(),激活say函数并且创建了它自己的执行上下</p><p>第三步say的执行上下文入栈，执行代码</p><p>第四步在say的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，say的上下文从栈中弹出。</p><p>第五步say的执行上下文弹出之后，继续执行readr的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样就只身下全局上下文了（关闭浏览器出栈）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xxx)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xxx)</span><br><span class="line">  &#125;</span><br><span class="line">    say();</span><br><span class="line">&#125;  </span><br><span class="line"> read();</span><br></pre></td></tr></table></figure><p>一、基础概念回顾<br>函数在被调用执行时，会创建一个当前函数的执行上下文。在该执行上下文的创建阶段，变量对象、作用域链、闭包、this指向会分别被确定。而一个JavaScript程序中一般来说会有多个函数，JavaScript引擎使用函数调用栈来管理这些函数的调用顺序。函数调用栈的调用顺序与栈数据结构一致。<br>二、认识断点调试工具<br>在尽量新版本的chrome浏览器中（不确定你用的老版本与我的一致），调出chrome浏览器的开发者工具。<br>浏览器右上角竖着的三点 -&gt; 更多工具 -&gt; 开发者工具 -&gt; Sources</p><p>界面如图。<br><img src="http://upload-images.jianshu.io/upload_images/3984027-89d5153a1f43c7b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">断点调试界面</p><p>在我的demo中，我把代码放在app.js中，在index.html中引入。我们暂时只需要关注截图中红色箭头的地方。在最右侧上方，有一排图标。我们可以通过使用他们来控制函数的执行顺序。从左到右他们依次是：<br>resume/pause script execution恢复/暂停脚本执行</p><p><strong>step over next function call</strong>跨过，实际表现是不遇到函数时，执行下一步。遇到函数时，不进入函数直接执行下一步。</p><p><strong>step into next function call</strong>跨入，实际表现是不遇到函数时，执行下一步。遇到到函数时，进入函数执行上下文。</p><p><strong>step out of current function</strong>跳出当前函数</p><p>deactivate breakpoints停用断点</p><p>don‘t pause on exceptions不暂停异常捕获</p><p>其中跨过，跨入，跳出是我使用最多的三个操作。<br>上图右侧第二个红色箭头指向的是函数调用栈（call Stack），这里会显示代码执行过程中，调用栈的变化。<br>右侧第三个红色箭头指向的是作用域链（Scope），这里会显示当前函数的作用域链。其中Local表示当前的局部变量对象，Closure表示当前作用域链中的闭包。借助此处的作用域链展示，我们可以很直观的判断出一个例子中，到底谁是闭包，对于闭包的深入了解具有非常重要的帮助作用。<br>三、断点设置<br>在显示代码行数的地方点击，即可设置一个断点。断点设置有以下几个特点：<br>在单独的变量声明(如果没有赋值)，函数声明的那一行，无法设置断点。</p><p>设置断点后刷新页面，JavaScript代码会执行到断点位置处暂停执行，然后我们就可以使用上边介绍过的几个操作开始调试了。</p><p>当你设置多个断点时，chrome工具会自动判断从最早执行的那个断点开始执行，因此我一般都是设置一个断点就行了。</p><p>四、实例<br>接下来，我们借助一些实例，来使用断点调试工具，看一看，我们的demo函数，在执行过程中的具体表现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// demo01</span></span><br><span class="line"> <span class="keyword">var</span> fn;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log( a );</span><br><span class="line">  &#125;</span><br><span class="line">  fn = baz; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>在向下阅读之前，我们可以停下来思考一下，这个例子中，谁是闭包？<br>这是来自《你不知道的js》中的一个例子。由于在使用断点调试过程中，发现chrome浏览器理解的闭包与该例子中所理解的闭包不太一致，因此专门挑出来，供大家参考。我个人更加倾向于chrome中的理解。<br>第一步：设置断点，然后刷新页面。</p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-f74352c169e0e0c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">设置断点</p><p>第二步：点击上图红色箭头指向的按钮（step into），该按钮的作用会根据代码执行顺序，一步一步向下执行。在点击的过程中，我们要注意观察下方call stack 与 scope的变化，以及函数执行位置的变化。</p><p>一步一步执行，当函数执行到上例子中<br><img src="http://upload-images.jianshu.io/upload_images/3984027-99783d3ecb101703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">baz函数被调用执行，foo形成了闭包</p><p>我们可以看到，在chrome工具的理解中，由于在foo内部声明的baz函数在调用时访问了它的变量a，因此foo成为了闭包。这好像和我们学习到的知识不太一样。我们来看看在《你不知道的js》这本书中的例子中的理解。<br><img src="http://upload-images.jianshu.io/upload_images/3984027-9c9862070feb225c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">你不知道的js中的例子</p><p>书中的注释可以明显的看出，作者认为fn为闭包。即baz，这和chrome工具中明显是不一样的。<br>而在备受大家推崇的《JavaScript高级编程》一书中，是这样定义闭包。<br><img src="http://upload-images.jianshu.io/upload_images/3984027-72a2951962962e4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">JavaScript高级编程中闭包的定义</p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-ba35a7892abdb764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">书中作者将自己理解的闭包与包含函数所区分</p><p>这里chrome中理解的闭包，与我所阅读的这几本书中的理解的闭包不一样。具体这里我先不下结论，但是我心中更加偏向于相信chrome浏览器。<br>我们修改一下demo01中的例子，来看看一个非常有意思的变化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> / <span class="regexp">/ demo02</span></span><br><span class="line"><span class="regexp">  var fn;</span></span><br><span class="line"><span class="regexp">  var m = 20;</span></span><br><span class="line"><span class="regexp">function foo() &#123;</span></span><br><span class="line"><span class="regexp">    var a = 2;</span></span><br><span class="line"><span class="regexp">function baz(a) &#123; </span></span><br><span class="line"><span class="regexp">    console.log(a);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">fn = baz; </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function bar() &#123;</span></span><br><span class="line"><span class="regexp">    fn(m); </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">foo();</span></span><br><span class="line"><span class="regexp">bar(); /</span><span class="regexp">/ 20</span></span><br></pre></td></tr></table></figure></p><p>这个例子在demo01的基础上，我在baz函数中传入一个参数，并打印出来。在调用时，我将全局的变量m传入。输出结果变为20。在使用断点调试看看作用域链。<br><img src="http://upload-images.jianshu.io/upload_images/3984027-e137ad4c3e6056a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">闭包没了，作用域链中没有包含foo了。</p><p>是不是结果有点意外，闭包没了，作用域链中没有包含foo了。我靠，跟我们理解的好像又有点不一样。所以通过这个对比，我们可以确定闭包的形成需要两个条件。<br>在函数内部创建新的函数；<br>新的函数在执行时，访问了函数的变量对象；</p><p>还有更有意思的。<br>我们继续来看看一个例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// demo03</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line"><span class="keyword">var</span> fn = bar();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p><p>在这个例子中，fn只访问了foo中的a变量，因此它的闭包只有foo。<br><img src="http://upload-images.jianshu.io/upload_images/3984027-e704c582d808e642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">闭包只有foo</p><p>修改一下demo03，我们在fn中也访问bar中b变量试试看。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// demo04</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line"><span class="keyword">var</span> fn = bar();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-5a1fefa9f4066ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">这个时候闭包变成了两个</p><p>这个时候，闭包变成了两个。分别是bar，foo。<br>我们知道，闭包在模块中的应用非常重要。因此，我们来一个模块的例子，也用断点工具来观察一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// demo05</span></span><br><span class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    m: <span class="number">20</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + x;</span><br><span class="line">    &#125;,</span><br><span class="line">    sum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + <span class="keyword">this</span>.m;</span><br><span class="line">    &#125;,</span><br><span class="line">    mark: <span class="function"><span class="keyword">function</span>(<span class="params">k, j</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.test = test;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">test.add(<span class="number">100</span>);</span><br><span class="line">test.sum();</span><br><span class="line">test.mark();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _mark = test.mark;</span><br><span class="line">_mark();</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-480bbb1caa5c48ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">add执行时，闭包为外层的自执行函数，this指向test</p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-035bc1d7bf55f5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">sum执行时，同上</p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-bbe4b78eda2d553c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">mark执行时，闭包为外层的自执行函数，this指向test</p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-dccd9d2ca1a03853.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">_mark执行时，闭包为外层的自执行函数，this指向window</p><p>注意：这里的this指向显示为Object或者Window，大写开头，他们表示的是实例的构造函数，实际上this是指向的具体实例<br>test.mark能形成闭包，跟下面的补充例子（demo07）情况是一样的。</p><p>我们还可以结合点断调试的方式，来理解那些困扰我们很久的this指向。随时观察this的指向，在实际开发调试中非常有用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    fn.call(obj); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3984027-3ce58f6b1739f3ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">this指向obj</p><p>补充一个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo07</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">          <span class="keyword">var</span> a = <span class="number">10</span>; </span><br><span class="line">         <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">             <span class="keyword">return</span> a;</span><br><span class="line">       &#125;</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">             &#125; </span><br><span class="line">           fn2();</span><br><span class="line">     &#125; </span><br><span class="line">          foo();</span><br></pre></td></tr></table></figure></p><p>这个例子，和其他例子不太一样。虽然fn2并没有访问到foo的变量，但是foo执行时仍然变成了闭包。而当我将fn1的声明去掉时，闭包便不会出现了。我暂时也不知道应该如何解释这种情况。只能大概知道与fn1有关，可能浏览器在实现时就认为只要存在访问上层作用域的可能性，就会被当成一个闭包吧。所以暂时就只能将它作为一个特例记住。<br>更多的例子，大家可以自行尝试，总之，学会了使用断点调试之后，我们就能够很轻松的了解一段代码的执行过程了。这对快速定位错误，快速了解他人的代码都有非常巨大的帮助。大家一定要动手实践，把它给学会。<br>最后，根据以上的摸索情况，再次总结一下闭包：<br>闭包是在函数被调用执行的时候才被确认创建的。</p><p>闭包的形成，与作用域链的访问顺序有直接关系。</p><p>只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;内存（堆与栈）&quot;&gt;&lt;a href=&quot;#内存（堆与栈）&quot; class=&quot;headerlink&quot; title=&quot;内存（堆与栈）&quot;&gt;&lt;/a&gt;内存（堆与栈）&lt;/h4&gt;&lt;p&gt;由于JavaScript存在垃圾自动回收机制，所以我们在开发中并不用像C和C++之类语言一样手动去跟
      
    
    </summary>
    
    
  </entry>
  
</feed>
